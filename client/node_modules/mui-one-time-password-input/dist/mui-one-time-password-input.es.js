import T from "react";
import L from "@mui/material/Box";
import { styled as W } from "@mui/material/styles";
import q from "@mui/material/TextField";
import { jsx as F } from "react/jsx-runtime";
const z = W(q)`
  input {
    text-align: center;
  }
`, G = {
  TextFieldStyled: z
}, H = (n) => /* @__PURE__ */ F(G.TextFieldStyled, {
  ...n
}), I = {
  left: "ArrowLeft",
  right: "ArrowRight",
  backspace: "Backspace"
};
function J(n, o) {
  return n <= 0 ? [] : Array.from({ length: n }, o);
}
function Q(n, o, i) {
  return n.map((s, l) => o === l ? i : s);
}
function w(n) {
  return n.join("");
}
function P(n, o) {
  return [...n, o];
}
function U(n, o, i) {
  return n.reduce(
    (s, l, d) => {
      const { characters: p, restArrayMerged: f } = s;
      if (d < i)
        return {
          restArrayMerged: f,
          characters: P(p, l)
        };
      const [h, ...g] = f;
      return {
        restArrayMerged: g,
        characters: P(p, h || "")
      };
    },
    {
      restArrayMerged: o,
      characters: []
    }
  ).characters;
}
function X(n) {
  return n.split("");
}
const Z = T.forwardRef((n, o) => {
  const {
    value: i,
    length: s,
    onChange: l,
    TextFieldsProps: d,
    onComplete: p,
    validateChar: f,
    className: h,
    ...g
  } = n, {
    onPaste: R,
    onFocus: S,
    onKeyDown: k,
    className: M,
    ...E
  } = d || {}, c = J(s, (e, r) => ({
    character: i[r] || "",
    inputRef: T.createRef()
  })), m = (e) => c.findIndex(({
    inputRef: r
  }) => r.current === e), C = () => c.map(({
    character: e
  }) => e), N = (e, r) => {
    const t = Q(C(), e, r);
    return w(t);
  }, D = (e) => {
    c[e]?.inputRef.current?.focus();
  }, A = (e) => {
    c[e]?.inputRef.current?.blur();
  }, u = (e) => {
    c[e]?.inputRef.current?.select();
  }, x = (e) => {
    e + 1 === s ? A(e) : c[e + 1].character ? u(e + 1) : D(e + 1);
  }, b = (e) => {
    e > 0 && u(e - 1);
  }, K = (e) => {
    const r = e.target.value[0] || "", t = m(e.target);
    if (typeof f == "function" && !f(r, t))
      return;
    const a = N(t, r);
    l?.(a), a.length === s && p?.(a), r !== "" ? a.length < s ? x(a.length - 1) : x(t) : a[t] ? u(t) : b(t);
  }, V = (e) => {
    e.preventDefault(), e.target.select(), S?.(e);
  }, j = (e) => {
    const r = e.target, t = m(r);
    r.value === e.key ? (e.preventDefault(), x(t)) : !r.value && I.backspace === e.key || I.left === e.key ? (e.preventDefault(), u(t - 1)) : I.right === e.key && (e.preventDefault(), u(t + 1)), k?.(e);
  }, $ = (e) => {
    e.preventDefault();
    const r = e.target, t = e.clipboardData.getData("text/plain"), a = m(r), Y = C(), B = U(Y, X(t), a), O = B.findIndex((_, v) => v > a && _ === ""), y = w(B);
    l?.(y), y.length === s && p?.(y), O !== -1 ? D(O) : A(a), R?.(e);
  };
  return /* @__PURE__ */ F(L, {
    display: "flex",
    gap: "20px",
    alignItems: "center",
    ref: o,
    className: `MuiOtpInput-Box ${h || ""}`,
    ...g,
    children: c.map(({
      character: e,
      inputRef: r
    }, t) => /* @__PURE__ */ F(H, {
      autoComplete: "one-time-code",
      value: e,
      inputRef: r,
      className: `MuiOtpInput-TextField MuiOtpInput-TextField-${t + 1} ${M || ""}`,
      onPaste: $,
      onFocus: V,
      onChange: K,
      onKeyDown: j,
      ...E
    }, t))
  });
});
Z.defaultProps = {
  value: "",
  length: 4,
  validateChar: () => !0,
  onChange: () => {
  },
  onComplete: () => {
  },
  TextFieldsProps: {}
};
export {
  Z as MuiOtpInput
};
